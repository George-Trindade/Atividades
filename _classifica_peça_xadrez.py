# -*- coding: utf-8 -*-
"""*Classifica_Peça_Xadrez.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BFFqV3lwcrHmoIVaqKsvM6OTEuPGErZn

# Importando as bibliotecas necessárias
"""

#TensorFlow + Keras
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import *

#Auxiliares
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import cv2

"""# Importando a base de dados
Foi utilizada um dataset de peças de xadrez, que contém aproximadamente 550 imagens, esta base é divida em subpastas com o devido nome das classes(Bispo,Cavalo,Peao,Rainha,Rei,Torre) respectivamente. 

Disponível em: https://drive.google.com/drive/folders/1rgrVLOh7yE7-38uo7InyDS0HnL942T1Y?usp=sharing
"""

#Importando o dataset e direcionando para o treinamento
train = keras.preprocessing.image_dataset_from_directory(
    '/content/drive/MyDrive/Chessman-image-dataset/Xadrez',
#Parâmetros padrões para definir as configurações dos dados e direcionar em um conjunto de treinamento
    validation_split=.2,
    subset='training',
    seed=42,
    image_size=(48, 48),
    batch_size=32,
    label_mode='categorical'
)

#Importando o dataset e direcionando para a validação
validation = keras.preprocessing.image_dataset_from_directory(
    '/content/drive/MyDrive/Chessman-image-dataset/Xadrez',
    #Parâmetros padrões para definir as configurações dos dados
    #(como o tamanho ou batch_size que é o tamanho do conjunto(número de amostras)) e
    #direcionar em um conjunto de treinamento
    validation_split=.2,
    subset='validation',
    seed=42,
    image_size=(48, 48),
    batch_size=32,
    label_mode='categorical'
)

#Dataset disponível em: https://drive.google.com/drive/folders/1rgrVLOh7yE7-38uo7InyDS0HnL942T1Y?usp=sharing
#Está no drive, pois o tensor flow é conectado neste meio, é só montar a pasta do drive
#Ele reconhecerá todas as pastas, basta selecionar e usar '/content/drive/Mydrive/nome_dataset'

"""# Criando o modelo

Montando as camadas
"""

#Montando as camadas
image_size = (48, 48)
#Definindo o tamanho do lote(dado) de treinamento, os tensores terão a mesma dimensão(3)
input_shape = (image_size[0], image_size[1], 3)
#Definindo o modelo para camadas simples(sequenciais)
model = keras.Sequential([
    #Cria um kernel de convolução que é convolvido com a entrada da camada para produzir um tensor de saídas
    #"Resumindo" as dimensões, definindo com espaço zero e informando as funções de ativação
    Conv2D(64, (3,3), input_shape=image_size + (3,), padding='same', activation='relu'),
    Conv2D(128, (3,3), padding='same', activation='relu'),
    #Reduz a resolução
    MaxPooling2D(pool_size=(2,2)),
    #Achata a entrada(reformata os dados)
    Flatten(),
    #Conecta a camada e passa a função de ativação
    Dense(256, activation='relu'),
    #Define a fração das unidades de entrada(flutua entre 0-1) 
    Dropout(0.5),
    #Dimensionando a saída(espaço)
    Dense(6, activation='softmax')
])

#Classes das imagens
train.class_names

"""Compilando o modelo"""

#Compilando o modelo
model.compile(
    #Definindo como o modelo se atualiza mediante a função loss
    optimizer='adam',
    #Medição da precisão do modelo
    loss='categorical_crossentropy',
    #Monitoração dos dados de treinamento, a acc usa uma fração das imagens que foram previstas com êxito 
    metrics=['accuracy'])

""" Treinando o modelo"""

#Alimentando com os dados, para que a IA possa aprender e associar cada imagem com sua respectiva classificação
model.fit(train,epochs=50,validation_data=validation)

"""Avaliando o modelo"""

#Testando a accurácia, que retorna a perfomance do teste 
test_loss, test_acc = model.evaluate(train, verbose=2)
print('\nTest accuracy:', test_acc)

"""Fazendo uma predição de uma imagem"""

#Fazendo uma predição de uma imagem qualquer
predictions = model.predict(train)
predictions[10]

#Pegando o array do resultado e convertendo em inteiro(número respectivo da classe indentificada) 
np.argmax(predictions[10])

#Apontando o resultado da predição com o, resultou em '0', as classes vão do 0 ao 6
train.class_names[0]

"""# Resultados
Foi testado uma imagem de cada classe

['Bispo', 'Cavalo', 'Peao', 'Rainha', 'Rei', 'Torre']=[   0   ,    1    ,    2  ,     3   ,   4  ,    5   ]

Bispo
"""

#Pegando uma imagem da base de dados e exibindo
objeto= cv2.imread('/content/drive/MyDrive/Chessman-image-dataset/Xadrez/Bispo/00000012.jpg')
plt.imshow(objeto)

#Exibindo as dimensões da imagem
print(objeto.shape)

#Reduzindo a imagem para 48x48 antes de realizar o teste
objeto=cv2.resize(objeto, (48,48))

#Conferindo as dimensões e atribuindo para outra variável, por padronização
img=objeto
print(img.shape)

#O keras realiza predições em massa, muitos itens de uma vez, mesmo que uma imagem é necessário pôr ela numa lista
img = (np.expand_dims(img,0))

#Fazendo a predição da imagem
predictions_single = model.predict(img)

print(predictions_single)

#Utilizando a função para converter o array num número inteiro, este que será o identificador da classe da imagem
#E ao invés de imprimir o número, será impresso a classe que a IA apontou
#Pegando o número e colocando como posição da lista de classes
#Se retornar 0 é o bispo, se 1 Cavalo...
print(train.class_names[np.argmax(predictions_single[0])])

"""Cavalo"""

#Teste com o cavalo 
objeto= cv2.imread('/content/drive/MyDrive/Chessman-image-dataset/Xadrez/Cavalo/00000097.jpg')
plt.imshow(objeto)

objeto=cv2.resize(objeto, (48,48))
img=objeto

img = (np.expand_dims(img,0))

predictions_single = model.predict(img)
print(predictions_single)

print(train.class_names[np.argmax(predictions_single[0])])

"""Peão"""

#Teste com o peão
objeto= cv2.imread('/content/drive/MyDrive/Chessman-image-dataset/Xadrez/Peao/00000004.jpg')
plt.imshow(objeto)

objeto=cv2.resize(objeto, (48,48))
img=objeto

img = (np.expand_dims(img,0))

predictions_single = model.predict(img)
print(predictions_single)

print(train.class_names[np.argmax(predictions_single[0])])

"""Rainha"""

#Teste com a rainha
objeto= cv2.imread('/content/drive/MyDrive/Chessman-image-dataset/Xadrez/Rainha/00000003.jpg')
plt.imshow(objeto)

objeto=cv2.resize(objeto, (48,48))
img=objeto

img = (np.expand_dims(img,0))

predictions_single = model.predict(img)
print(predictions_single)

print(train.class_names[np.argmax(predictions_single[0])])

"""Rei"""

#Teste com o rei
objeto= cv2.imread('/content/drive/MyDrive/Chessman-image-dataset/Xadrez/Rei/00000007.jpg')
plt.imshow(objeto)

objeto=cv2.resize(objeto, (48,48))
img=objeto

img = (np.expand_dims(img,0))

predictions_single = model.predict(img)
print(predictions_single)

print(train.class_names[np.argmax(predictions_single[0])])

"""Torre"""

#Por último, teste com a torre 
objeto= cv2.imread('/content/drive/MyDrive/Chessman-image-dataset/Xadrez/Torre/00000006.jpg')
plt.imshow(objeto)

objeto=cv2.resize(objeto, (48,48))
img=objeto

img = (np.expand_dims(img,0))

predictions_single = model.predict(img)
print(predictions_single)

print(train.class_names[np.argmax(predictions_single[0])])

#By George Trindade